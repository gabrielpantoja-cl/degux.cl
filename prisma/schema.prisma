generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("POSTGRES_PRISMA_URL")
  extensions = [postgis]
}

// âœ… MODELO ACCOUNT CORREGIDO - Compatible con NextAuth.js
model Account {
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  id                String   @id
  // âœ… CAMBIADO: User -> user (minÃºscula) para compatibilidad con NextAuth
  user              User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model AuditLog {
  id        String   @id
  userId    String
  action    String
  metadata  Json?
  createdAt DateTime @default(now())
  // âœ… CAMBIADO: User -> user (minÃºscula)
  user      User     @relation(fields: [userId], references: [id])
}

model ChatMessage {
  id        String      @id
  userId    String
  role      MessageRole
  content   String
  createdAt DateTime    @default(now())
  // âœ… CAMBIADO: User -> user (minÃºscula)
  user      User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
}

// âœ… MODELO SESSION CORREGIDO - Compatible con NextAuth.js
model Session {
  id           String   @id
  sessionToken String   @unique
  userId       String
  expires      DateTime
  // âœ… CAMBIADO: User -> user (minÃºscula) para compatibilidad con NextAuth
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// âœ… MODELO USER ACTUALIZADO - Referencias corregidas + Perfil Profesional
model User {
  id            String          @id
  name          String?
  email         String          @unique
  password      String?
  emailVerified DateTime?
  image         String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  role          Role            @default(user)

  // ðŸ†• CAMPOS DE PERFIL PROFESIONAL (Fase 1)
  bio              String?
  profession       ProfessionType?
  company          String?
  phone            String?
  region           String?
  commune          String?
  website          String?
  linkedin         String?
  isPublicProfile  Boolean        @default(false)

  // âœ… ACTUALIZADAS: Todas las referencias a minÃºsculas
  accounts      Account[]
  auditLogs     AuditLog[]
  chatMessages  ChatMessage[]
  sessions      Session[]
  referenciales referenciales[]

  // ðŸ†• NUEVAS RELACIONES (Fase 1)
  properties           Property[]
  connectionsInitiated Connection[] @relation("ConnectionRequester")
  connectionsReceived  Connection[] @relation("ConnectionReceiver")
}

model VerificationToken {
  identifier String   @unique
  token      String
  expires    DateTime

  @@id([identifier, token])
}

model conservadores {
  id            String          @id
  nombre        String
  direccion     String
  comuna        String
  region        String
  telefono      String?
  email         String?
  sitioWeb      String?
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  referenciales referenciales[]
}

model referenciales {
  id             String                   @id
  lat            Float
  lng            Float
  fojas          String
  numero         Int
  anio           Int
  cbr            String
  comprador      String
  vendedor       String
  predio         String
  comuna         String
  rol            String
  fechaescritura DateTime
  superficie     Float
  monto          BigInt?
  observaciones  String?
  userId         String?
  conservadorId  String
  geom           Unsupported("geometry")?
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  conservadores  conservadores            @relation(fields: [conservadorId], references: [id])
  // âœ… CAMBIADO: User -> user (minÃºscula) + OPCIONAL para datos de N8N
  user           User?                    @relation(fields: [userId], references: [id])
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model spatial_ref_sys {
  srid      Int     @id
  auth_name String? @db.VarChar(256)
  auth_srid Int?
  srtext    String? @db.VarChar(2048)
  proj4text String? @db.VarChar(2048)
}

// ðŸ†• FASE 1: Modelo Property (Propiedades listadas por usuarios)
model Property {
  id          String         @id
  userId      String
  title       String
  description String?
  propertyType PropertyType
  status      PropertyStatus @default(available)

  // UbicaciÃ³n
  address     String
  commune     String
  region      String
  lat         Float?
  lng         Float?

  // CaracterÃ­sticas
  bedrooms    Int?
  bathrooms   Int?
  parkingSpots Int?
  totalSurface Float?
  builtSurface Float?

  // Precio
  price       BigInt
  currency    String         @default("CLP")

  // ImÃ¡genes
  images      String[]       @default([])
  mainImage   String?

  // Metadata
  featured    Boolean        @default(false)
  views       Int            @default(0)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([commune, status])
  @@index([propertyType, status])
}

// ðŸ†• FASE 1: Modelo Connection (Red de networking)
model Connection {
  id          String           @id
  requesterId String
  receiverId  String
  status      ConnectionStatus @default(pending)
  message     String?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  requester   User             @relation("ConnectionRequester", fields: [requesterId], references: [id], onDelete: Cascade)
  receiver    User             @relation("ConnectionReceiver", fields: [receiverId], references: [id], onDelete: Cascade)

  @@unique([requesterId, receiverId])
  @@index([requesterId, status])
  @@index([receiverId, status])
}

enum MessageRole {
  user
  bot
}

enum Role {
  user
  admin
  superadmin
}

// ðŸ†• FASE 1: Enums para Perfiles y Propiedades
enum ProfessionType {
  CORREDOR
  TASADOR
  ARQUITECTO
  CONSTRUCTOR
  INGENIERO
  INVERSIONISTA
  ABOGADO
  OTRO
}

enum PropertyType {
  CASA
  DEPARTAMENTO
  TERRENO
  LOCAL_COMERCIAL
  OFICINA
  BODEGA
  PARCELA
  OTRO
}

enum PropertyStatus {
  available
  reserved
  sold
  inactive
}

enum ConnectionStatus {
  pending
  accepted
  rejected
  blocked
}
